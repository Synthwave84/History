-- 계층형 쿼리
/*
계층형 쿼리HierarchicalQuery 는 2차원 형태의 테이블에 저장된 데이터를 계층형 구조로 결과를 반환하는 쿼리를 말한다. 
계층형 구조란 상하 수직 관계의 구조로 사원-대리-과장-부장과 같은 직급, 판매부-영업부 같은 부서 구조, 대학의 학과, 정부 부처 등이 계층형 구조에 속한다.
또한 엑셀과 같은 프로그램의 메뉴 구조, 답변형 게시판뿐만 아니라 이 책의 목차도 이에 포함된다.
*/

-- 오라클의 계층형쿼리 문법이 지원 안될 때에는 아래 구문으로 계층형 구조결과를 대신하는 쿼리.
SELECT  DEPARTMENT_ID, 
        DEPARTMENT_NAME, 
        0 AS PARENT_ID,
        1 AS LEVELS,
        PARENT_ID || DEPARTMENT_ID AS SORT
FROM    DEPARTMENTS 
WHERE   PARENT_ID IS NULL
UNION ALL
SELECT  T2.DEPARTMENT_ID, 
        LPAD(' ' , 3 * (2-1)) || T2.DEPARTMENT_NAME AS DEPARTMENT_NAME, 
        T2.PARENT_ID,
        2 AS LEVELS,
        T2.PARENT_ID || T2.DEPARTMENT_ID AS SORT
FROM    DEPARTMENTS T1,
        DEPARTMENTS T2
WHERE   T1.PARENT_ID IS NULL
  AND   T2.PARENT_ID = T1.DEPARTMENT_ID
UNION ALL
SELECT  T3.DEPARTMENT_ID, 
        LPAD(' ' , 3 * (3-1)) || T3.DEPARTMENT_NAME AS DEPARTMENT_NAME, 
        T3.PARENT_ID,
        3 AS LEVELS,
        T2.PARENT_ID || T3.PARENT_ID || T3.DEPARTMENT_ID AS SORT
FROM    DEPARTMENTS T1,
        DEPARTMENTS T2,
        DEPARTMENTS T3
WHERE   T1.PARENT_ID IS NULL
  AND   T2.PARENT_ID = T1.DEPARTMENT_ID
  AND   T3.PARENT_ID = T2.DEPARTMENT_ID
UNION ALL
SELECT  T4.DEPARTMENT_ID, 
        LPAD(' ' , 3 * (4-1)) || T4.DEPARTMENT_NAME AS DEPARTMENT_NAME, 
        T4.PARENT_ID,
        4 AS LEVELS,
        T2.PARENT_ID || T3.PARENT_ID || T4.PARENT_ID || T4.DEPARTMENT_ID AS SORT
FROM    DEPARTMENTS T1,
        DEPARTMENTS T2,
        DEPARTMENTS T3,
        DEPARTMENTS T4
WHERE   T1.PARENT_ID IS NULL
  AND   T2.PARENT_ID = T1.DEPARTMENT_ID
  AND   T3.PARENT_ID = T2.DEPARTMENT_ID
  AND   T4.PARENT_ID = T3.DEPARTMENT_ID
ORDER BY SORT;

/*
    SELECT expr1, expr2, ...
      FROM 테이블
     WHERE 조건
     START WITH[최상위 조건] -- 최상위 데이터를 지정
    CONNECT BY [NOCYCLE][PRIOR 계층형 구조 조건];
*/    

/*
department_id : 자식컬럼
parent_id : 부모컬럼
*/

--1)  상위레벨 -> 하위레벨 수준으로 데이타 출력
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL
  FROM DEPARTMENTS
  START WITH PARENT_ID IS NULL  -- 루트가 상위로 본다.
  CONNECT BY PRIOR DEPARTMENT_ID  = PARENT_ID;  -- prior 키워드가 자식컬럼(department_id) 앞에 사용
 
 
  
SELECT      DEPARTMENT_ID, LPAD(' ', 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL
FROM        DEPARTMENTS
-- 최상위 조건
START WITH  PARENT_ID IS NULL
-- 컬럼 둘중 하나에 PRIOR를 입력해 주어야한다.
CONNECT BY  PRIOR DEPARTMENT_ID = PARENT_ID;

--2)  하위레벨 -> 상위레벨 수준으로 데이타 출력  
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL
FROM DEPARTMENTS
START WITH PARENT_ID IS NULL -- 루트가 하위로 본다.
CONNECT BY DEPARTMENT_ID  = PRIOR PARENT_ID;  -- prior 키워드가 부모컬럼(parent_id) 앞에 사용


-- 구매/생산부를 루트로 지정하여, 하위레벨에서 상위레벨로 출력하라.
SELECT      DEPARTMENT_ID, LPAD(' ', 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL
FROM        DEPARTMENTS
START WITH  DEPARTMENT_ID = 30   -- 30   구매/생산부
CONNECT BY  DEPARTMENT_ID = PRIOR PARENT_ID;

-- 구매/생산부를 루트로 지정하여, 상위레벨에서 하위레벨로 출력하라.
SELECT      DEPARTMENT_ID, LPAD(' ', 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL
FROM        DEPARTMENTS
START WITH  DEPARTMENT_ID = 30   -- 30   구매/생산부
CONNECT BY  PRIOR DEPARTMENT_ID =  PARENT_ID;


-- 조인 형태
SELECT      *
FROM        EMPLOYEES;

SELECT      EMPLOYEE_ID, MANAGER_ID
FROM        EMPLOYEES
START WITH  MANAGER_ID IS NULL
CONNECT BY  PRIOR EMPLOYEE_ID = MANAGER_ID;


-- 상급자에서 하급자레벨로 출력하라.  
SELECT A.EMPLOYEE_ID, LPAD(' ' , 3 * (LEVEL-1)) || A.EMP_NAME, 
       LEVEL,
       B.DEPARTMENT_NAME
  FROM EMPLOYEES A,
       DEPARTMENTS B
 WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID
 START WITH A.MANAGER_ID IS NULL
 CONNECT BY PRIOR A.EMPLOYEE_ID = A.MANAGER_ID;


--1) START WITH a.manager_id IS NULL 루트지정한 데이타가 출력안됨.
SELECT A.EMPLOYEE_ID, LPAD(' ' , 3 * (LEVEL-1)) || A.EMP_NAME, 
       LEVEL,
       B.DEPARTMENT_NAME, A.DEPARTMENT_ID
  FROM EMPLOYEES A,
       DEPARTMENTS B
 WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID
   AND A.DEPARTMENT_ID = 30 -- 부서가 30번이 데이타를 전제조건.
 START WITH A.MANAGER_ID IS NULL
 CONNECT BY NOCYCLE PRIOR A.EMPLOYEE_ID = A.MANAGER_ID;

--2)계층형쿼리 이후에 조건식이 사용되면, 루트지정한 데이타가 포함되어 출력된다.
SELECT A.EMPLOYEE_ID, LPAD(' ' , 3 * (LEVEL-1)) || A.EMP_NAME, 
       LEVEL,
       B.DEPARTMENT_NAME, A.DEPARTMENT_ID
  FROM EMPLOYEES A,
       DEPARTMENTS B
 WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID
 START WITH A.MANAGER_ID IS NULL
 CONNECT BY NOCYCLE PRIOR A.EMPLOYEE_ID = A.MANAGER_ID
     AND A.DEPARTMENT_ID = 30; -- 
  
-- 계층형 정렬하기.  

-- ORDER BY 키워드 사용시, 계층형 구조가 유지되지 않고, 단순하게 정렬된다.
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL
  FROM DEPARTMENTS
  START WITH PARENT_ID IS NULL
  CONNECT BY PRIOR DEPARTMENT_ID  = PARENT_ID
  ORDER BY DEPARTMENT_NAME;  

-- ORDER SIBLINGS BY : 계층형 구조가 유지된 상태에서 정렬  
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL
  FROM DEPARTMENTS
  START WITH PARENT_ID IS NULL
  CONNECT BY PRIOR DEPARTMENT_ID  = PARENT_ID
  ORDER SIBLINGS BY DEPARTMENT_NAME;    

/*
② CONNECT_BY_ROOT
CONNECT_BY_ROOT는 계층형 쿼리에서 최상위 로우를 반환하는 연산자다
*/

-- 에러발생. > CONNECT_BY_ROOT 에 부서명을 필수적으로 입력해 주어야한다.-
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL, CONNECT_BY_ROOT
  FROM DEPARTMENTS
  START WITH PARENT_ID IS NULL
  CONNECT BY PRIOR DEPARTMENT_ID  = PARENT_ID
  ORDER SIBLINGS BY DEPARTMENT_NAME;      
  
  
-- 최상위 부서명을 출력함.  
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL, 
       CONNECT_BY_ROOT DEPARTMENT_NAME AS ROOT_NAME
  FROM DEPARTMENTS
  START WITH PARENT_ID IS NULL
  CONNECT BY PRIOR DEPARTMENT_ID  = PARENT_ID;
/*
③ CONNECT_BY_ISLEAF : 하위레벨 존재유무를 확인가능하다.
CONNECT_BY_ISLEAF는 CONNECT BY 조건에 정의된 관계에 따라 
해당 로우가 최하위 자식 로우이면 1을, 그렇지 않으면 0을 반환하는 의사 컬럼이다.
*/
  
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL, CONNECT_BY_ISLEAF
  FROM DEPARTMENTS
  START WITH PARENT_ID IS NULL
  CONNECT BY PRIOR DEPARTMENT_ID  = PARENT_ID;  
 
/*
④ SYS_CONNECT_BY_PATH (colm, char)
SYS_CONNECT_BY_PATH는 계층형 쿼리에서만 사용할 수 있는 함수로, 
루트 노드에서 시작해 자신의 행까지 연결된 경로 정보를 반환한다. 
이 함수의 첫 번째 파라미터로는 컬럼이, 두 번째 파라미터인 char은 컬럼 간 구분자를 의미한다.
*/
  
-- 현재 결과값에 보면 구매/ 생산부 컬럼에 '/'가 있는데, 이것을 사용해선 안된다.
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL, 
       SYS_CONNECT_BY_PATH( DEPARTMENT_NAME, '->')
  FROM DEPARTMENTS
  START WITH PARENT_ID IS NULL
  CONNECT BY PRIOR DEPARTMENT_ID  = PARENT_ID;   
 
 /*
 SYS_CONNECT_BY_PATH( department_name, '/')
 두 번째 매개변수인 구분자로 해당 컬럼 값에 포함된 문자는 사용할 수 없다는 점을 주의해야 한다. 
구매/생산부는 ‘/’문자가 속해 있는데, 구분자로 ‘/’를 사용하면 다음과 같은 오류가 발생한다
 */
 
 -- 에러발생 :  department_name컬럼에 "구매/생산부"   데이터가 존재한다. / 를 포함하고 있다.
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL, 
       SYS_CONNECT_BY_PATH( DEPARTMENT_NAME, '/')
  FROM DEPARTMENTS
  START WITH PARENT_ID IS NULL
  CONNECT BY PRIOR DEPARTMENT_ID  = PARENT_ID;     
 
/*
⑤ CONNECT_BY_ISCYCLE
눈치챘는지는 모르겠지만 오라클의 계층형 쿼리는 루프(반복) 알고리즘을 사용한다. 
계층형 구조나 레벨은 테이블에 있는 데이터에 따라 동적으로 변경되므로, 내부적으로는 루프를 돌며 자식 노드를 찾아간다. 
루프 알고리즘에서 주의할 점은 조건을 잘못 주면 무한루프를 타게 된다는 점인데, 
계층형 쿼리에서도 부모-자식 간의 관계를 정의하는 값이 잘못 입력되면 무한루프를 타고 오류가 발생한다.
*/
 
/*
무한 루프가 발생되는 데이타 변경작업을하여, 테스트하는 시나리오.

예를 들어, 생산팀(170)의 부모 부서는 구매/생산부(30)인데, 
구매/생산부의 parent_id 값을 생산부로 바꾸면 두 부서가 상호 참조가 되어 무한루프가 발생할 것이다. 직접 확인해 보자.
*/

--   구매/생산부의 parent_id 값을 생산부 10번에서 170번으로 변경작업을 한다. 결과는 계층형쿼리에서 무한루프가 발생된다.
UPDATE DEPARTMENTS
   SET PARENT_ID = 170
 WHERE DEPARTMENT_ID = 30;
 
 
-- 부서코드가 30을 루트지정 .
-- 상위레벨에서 하위레벨로 출력
-- 데이터가 잘못 입력되어, 무한루프 에러 발생. CONNECT BY loop in user data
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL, 
       PARENT_ID
  FROM DEPARTMENTS
  START WITH DEPARTMENT_ID = 30 -- 상위레벨
CONNECT BY PRIOR DEPARTMENT_ID  = PARENT_ID; 

/*
이때는 루프가 발생된 원인을 찾아 잘못된 데이터를 수정해야 하는데, 
이를 위해서는 먼저 CONNECT BY 절에 NOCYCLE을 추가하고 
SELECT 절에 CONNECT_BY_ISCYCLE 의사 컬럼을 사용해 찾을 수 있다. 
CONNECT_BY_ISCYCLE은 다음과 같이 현재 로우가 자식을 갖고 있는데 
동시에 그 자식 로우가 부모 로우이면 1을, 그렇지 않으면 0을 반환한다.
*/

-- 시스템 패키지
DBMS


SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LEVEL-1)) || DEPARTMENT_NAME AS DEPNAME, LEVEL, 
       CONNECT_BY_ISCYCLE ISLOOP,
       PARENT_ID
  FROM DEPARTMENTS
  START WITH DEPARTMENT_ID = 30
CONNECT BY NOCYCLE PRIOR DEPARTMENT_ID  = PARENT_ID; 

-- 루프 발생시킨 데이타를 확인한다.
-- 원래 상태로 다시 변경한다. 170 -> 10 코드로 변경
UPDATE DEPARTMENTS
   SET PARENT_ID = 10
 WHERE DEPARTMENT_ID = 30;
  
  
-- 계층형 쿼리 응용 
-- 샘플 데이터 생성  

-- 시스템 패키지 : 오라클에서 제공하는 명령어의 집합체.
-- DBMS_RANDOM 패키지.
-- 주요기능 : 랜덤한 숫자나 문자열 만들때 사용.



SET SERVEROUTPUT ON;

SET SERVEROUTPUT OFF;

-- 랜덤값 생성(양수 또는 음수)
SELECT DBMS_RANDOM.RANDOM FROM DUAL;

-- 0~1 범위 사이의 랜덤 값 생성
SELECT SYS.DBMS_RANDOM.VALUE FROM DUAL;

-- 1~1000 사이의 랜덤 값 생성
SELECT DBMS_RANDOM.VALUE(1, 1000) FROM DUAL;

SELECT TRUNC(DBMS_RANDOM.VALUE(1, 1000), -1) FROM DUAL;

-- 12자리 랜덤값 생성
SELECT DBMS_RANDOM.VALUE(100000000000, 999999999999) FROM DUAL;

-- 대문자 20자리 랜덤 문자열 생성
SELECT DBMS_RANDOM.STRING('U', 20) FROM DUAL; -- NVWTRENTWJWZTFHAFIYO

-- 소문자 20자리 랜덤 문자열 생성
SELECT DBMS_RANDOM.STRING('L', 20) FROM DUAL; -- gfjxzhhkqhogifqlnaig

-- 대소문자 혼합 20자리 랜덤 문자열 생성
SELECT DBMS_RANDOM.STRING('A', 20) FROM DUAL; -- FWqmZRnYSooxFRWrSsfn

-- 대문자, 숫자 혼합 20자리 랜덤 문자열 생성
SELECT DBMS_RANDOM.STRING('X', 20) FROM DUAL; -- A77BYPBI7IJJY339H0E8

-- 출력가능한 특수문자포함 20자리 랜덤 문자열 생성
SELECT DBMS_RANDOM.STRING('P', 20) FROM DUAL; -- )ge]&h\yTf8 e>%s+K`a

-- CONNECT BY LEVEL <= 숫자
SELECT DBMS_RANDOM.VALUE(1000, 10000) FROM DUAL;

SELECT CEIL(DBMS_RANDOM.VALUE(1000, 10000)) FROM DUAL;

-- 정수로만 1000~10000 범위에서 임의의 수를 10개 생성하자.
SELECT CEIL(DBMS_RANDOM.VALUE(1000, 10000)) FROM DUAL
CONNECT BY LEVEL <= 10;

-- 테이블 생성(데이타포함) : 데이타 백업 
-- 샘플데이타 작업
CREATE TABLE EX7_1 AS  
SELECT ROWNUM SEQ, 
       '2014' || LPAD(CEIL(ROWNUM/1000) , 2, '0' ) MONTH,
        ROUND(DBMS_RANDOM.VALUE (100, 1000)) AMT
FROM DUAL
CONNECT BY LEVEL <= 12000;

-- 2014년도 01월~12월 데이타를 가공작업
-- ROWNUM 1~1000
SELECT CEIL(1/1000), CEIL(999/1000), CEIL(1000/1000) FROM DUAL;

-- -- ROWNUM 1001~2000
SELECT CEIL(1001/1000), CEIL(1999/1000), CEIL(2000/1000) FROM DUAL;


-- 참고. INSERT~SELECT 구문.
/*
INSERT INTO 테이블명A
SELECT 컬럼1, 컬럼2 FROM 테이블명B
*/


-- 3월29일까지 진행됨.

SELECT *
  FROM EX7_1;
  
SELECT MONTH, SUM(AMT)
FROM EX7_1
GROUP BY MONTH
ORDER BY MONTH;

SELECT ROWNUM
FROM (
       SELECT 1 AS ROW_NUM
         FROM DUAL
        UNION ALL
       SELECT 1 AS ROW_NUM
         FROM DUAL
)
CONNECT BY LEVEL <= 4;
  
-- 로우를 컬럼으로

CREATE TABLE EX7_2 AS
  SELECT DEPARTMENT_ID,
         LISTAGG(EMP_NAME, ',') WITHIN GROUP (ORDER BY EMP_NAME) AS EMPNAMES
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID IS NOT NULL
  GROUP BY DEPARTMENT_ID;
  
  
SELECT *
FROM EX7_2;

-- 컬럼을 로우로
  
SELECT EMPNAMES,
       DECODE(LEVEL, 1, 1, INSTR(EMPNAMES, ',', 1, LEVEL-1)) ST,
       INSTR(EMPNAMES, ',', 1, LEVEL) ED,
       LEVEL AS LVL
 FROM ( SELECT EMPNAMES || ',' AS EMPNAMES,
               LENGTH(EMPNAMES) ORI_LEN,
               LENGTH(REPLACE(EMPNAMES, ',', '')) NEW_LEN
          FROM EX7_2
         WHERE DEPARTMENT_ID = 90
       )
 CONNECT BY LEVEL <= ORI_LEN - NEW_LEN + 1;
 
 
SELECT EMPNAMES,
       DECODE(LEVEL, 1, 1, INSTR(EMPNAMES, ',', 1, LEVEL-1)) START_POS,
       INSTR(EMPNAMES, ',', 1, LEVEL) END_POS,
       LEVEL AS LVL
  FROM (  SELECT EMPNAMES || ',' AS EMPNAMES,
                 LENGTH(EMPNAMES) ORI_LEN,
                 LENGTH(REPLACE(EMPNAMES, ',', '')) NEW_LEN
            FROM EX7_2
           WHERE DEPARTMENT_ID = 90
        )
  CONNECT BY LEVEL <= ORI_LEN - NEW_LEN + 1; 
  
  
SELECT REPLACE(SUBSTR(EMPNAMES, START_POS, END_POS - START_POS), ',', '') AS EMP
FROM ( SELECT EMPNAMES,
              DECODE(LEVEL, 1, 1, INSTR(EMPNAMES, ',', 1, LEVEL-1)) START_POS,
              INSTR(EMPNAMES, ',', 1, LEVEL) END_POS,
              LEVEL AS LVL
      FROM (  SELECT EMPNAMES || ',' AS EMPNAMES,
                     LENGTH(EMPNAMES) ORI_LEN,
                     LENGTH(REPLACE(EMPNAMES, ',', '')) NEW_LEN
                FROM EX7_2
               WHERE DEPARTMENT_ID = 90
           )
      CONNECT BY LEVEL <= ORI_LEN - NEW_LEN + 1
) ;
                  
  
-- WITH 절
  
SELECT B2.*
FROM ( SELECT PERIOD, REGION, SUM(LOAN_JAN_AMT) JAN_AMT
         FROM KOR_LOAN_STATUS 
         GROUP BY PERIOD, REGION
      ) B2,      
      ( SELECT B.PERIOD,  MAX(B.JAN_AMT) MAX_JAN_AMT
         FROM ( SELECT PERIOD, REGION, SUM(LOAN_JAN_AMT) JAN_AMT
                  FROM KOR_LOAN_STATUS 
                 GROUP BY PERIOD, REGION
              ) B,
              ( SELECT MAX(PERIOD) MAX_MONTH
                  FROM KOR_LOAN_STATUS
                 GROUP BY SUBSTR(PERIOD, 1, 4)
              ) A
         WHERE B.PERIOD = A.MAX_MONTH
         GROUP BY B.PERIOD
      ) C   
 WHERE B2.PERIOD = C.PERIOD
   AND B2.JAN_AMT = C.MAX_JAN_AMT
 ORDER BY 1;


WITH B2 AS ( SELECT PERIOD, REGION, SUM(LOAN_JAN_AMT) JAN_AMT
               FROM KOR_LOAN_STATUS 
              GROUP BY PERIOD, REGION
           ),
     C AS ( SELECT B.PERIOD,  MAX(B.JAN_AMT) MAX_JAN_AMT
              FROM ( SELECT PERIOD, REGION, SUM(LOAN_JAN_AMT) JAN_AMT
                      FROM KOR_LOAN_STATUS 
                     GROUP BY PERIOD, REGION
                   ) B,
                   ( SELECT MAX(PERIOD) MAX_MONTH
                       FROM KOR_LOAN_STATUS
                      GROUP BY SUBSTR(PERIOD, 1, 4)
                   ) A
             WHERE B.PERIOD = A.MAX_MONTH
             GROUP BY B.PERIOD
           )
SELECT B2.*
  FROM B2, C
 WHERE B2.PERIOD = C.PERIOD
   AND B2.JAN_AMT = C.MAX_JAN_AMT
 ORDER BY 1;           
           
           
-- 순환 서브쿼리
           
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL
  FROM DEPARTMENTS
  START WITH PARENT_ID IS NULL
  CONNECT BY PRIOR DEPARTMENT_ID  = PARENT_ID;
  
WITH RECUR ( DEPARTMENT_ID, PARENT_ID, DEPARTMENT_NAME, LVL)
        AS ( SELECT DEPARTMENT_ID, PARENT_ID, DEPARTMENT_NAME, 1 AS LVL
               FROM DEPARTMENTS
              WHERE PARENT_ID IS NULL
              UNION ALL
             SELECT A.DEPARTMENT_ID, A.PARENT_ID, A.DEPARTMENT_NAME, B.LVL + 1 
               FROM DEPARTMENTS A, RECUR B
              WHERE A.PARENT_ID = B.DEPARTMENT_ID 
              )             
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LVL-1)) || DEPARTMENT_NAME, LVL
 FROM RECUR;
 
 
WITH RECUR ( DEPARTMENT_ID, PARENT_ID, DEPARTMENT_NAME, LVL)
        AS ( SELECT DEPARTMENT_ID, PARENT_ID, DEPARTMENT_NAME, 1 AS LVL
               FROM DEPARTMENTS
              WHERE PARENT_ID IS NULL
              UNION ALL
             SELECT A.DEPARTMENT_ID, A.PARENT_ID, A.DEPARTMENT_NAME, B.LVL + 1 
               FROM DEPARTMENTS A, RECUR B
              WHERE A.PARENT_ID = B.DEPARTMENT_ID 
              )       
SEARCH DEPTH FIRST BY DEPARTMENT_ID SET ORDER_SEQ                       
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LVL-1)) || DEPARTMENT_NAME, LVL, ORDER_SEQ
 FROM RECUR; 


-- 분석함수

SELECT DEPARTMENT_ID, EMP_NAME, 
       ROW_NUMBER() OVER (PARTITION BY DEPARTMENT_ID 
                          ORDER BY EMP_NAME ) DEP_ROWS
  FROM EMPLOYEES;
  
  
SELECT DEPARTMENT_ID, EMP_NAME, 
       SALARY,
       RANK() OVER (PARTITION BY DEPARTMENT_ID 
                    ORDER BY SALARY ) DEP_RANK
  FROM EMPLOYEES;
  
SELECT DEPARTMENT_ID, EMP_NAME, 
       SALARY,
       DENSE_RANK() OVER (PARTITION BY DEPARTMENT_ID 
                    ORDER BY SALARY ) DEP_RANK
  FROM EMPLOYEES;
  
SELECT *
FROM ( SELECT DEPARTMENT_ID, EMP_NAME, 
              SALARY, 
              DENSE_RANK() OVER (PARTITION BY DEPARTMENT_ID 
                                 ORDER BY SALARY DESC) DEP_RANK
         FROM EMPLOYEES
     )
WHERE DEP_RANK <= 3;  
    
    
SELECT DEPARTMENT_ID, EMP_NAME, 
       SALARY,
       CUME_DIST() OVER (PARTITION BY DEPARTMENT_ID 
                         ORDER BY SALARY ) DEP_DIST
  FROM EMPLOYEES;    
  
  
SELECT DEPARTMENT_ID, EMP_NAME, 
       SALARY
      ,RANK() OVER (PARTITION BY DEPARTMENT_ID 
                         ORDER BY SALARY ) RAKING
      ,CUME_DIST() OVER (PARTITION BY DEPARTMENT_ID 
                         ORDER BY SALARY ) CUME_DIST_VALUE
      ,PERCENT_RANK() OVER (PARTITION BY DEPARTMENT_ID 
                         ORDER BY SALARY ) PERCENTILE
  FROM EMPLOYEES
WHERE DEPARTMENT_ID = 60;  

SELECT DEPARTMENT_ID, EMP_NAME, 
       SALARY
      ,NTILE(4) OVER (PARTITION BY DEPARTMENT_ID 
                         ORDER BY SALARY 
                      ) NTILES
  FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (30, 60) ;

SELECT EMP_NAME, HIRE_DATE, SALARY,
       LAG(SALARY, 1, 0)  OVER (ORDER BY HIRE_DATE) AS PREV_SAL,
       LEAD(SALARY, 1, 0) OVER (ORDER BY HIRE_DATE) AS NEXT_SAL
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID = 30;
 
SELECT EMP_NAME, HIRE_DATE, SALARY,
       LAG(SALARY, 2, 0)  OVER (ORDER BY HIRE_DATE) AS PREV_SAL,
       LEAD(SALARY, 2, 0) OVER (ORDER BY HIRE_DATE) AS NEXT_SAL
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID = 30;
 
 
-- Window절
 
SELECT DEPARTMENT_ID, EMP_NAME, HIRE_DATE, SALARY,
       SUM(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                         ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                         ) AS ALL_SALARY,
       SUM(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                         ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
                         ) AS FIRST_CURRENT_SAL,
       SUM(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                         ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
                         ) AS CURRENT_END_SAL
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID IN (30, 90);
 
SELECT DEPARTMENT_ID, EMP_NAME, HIRE_DATE, SALARY,
       SUM(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                         RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                         ) AS ALL_SALARY,
       SUM(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                         RANGE 365 PRECEDING
                         ) AS RANGE_SAL1,
       SUM(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                         RANGE BETWEEN 365 PRECEDING AND CURRENT ROW
                         ) AS RANGE_SAL2
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID = 30; 
 
 
SELECT DEPARTMENT_ID, EMP_NAME, HIRE_DATE, SALARY,
       FIRST_VALUE(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                                 ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                                ) AS ALL_SALARY,
       FIRST_VALUE(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                                 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
                                ) AS FR_ST_TO_CURRENT_SAL,
       FIRST_VALUE(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                                 ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
                                ) AS FR_CURRENT_TO_END_SAL
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID IN (30, 90); 
 
 
 SELECT DEPARTMENT_ID, EMP_NAME, HIRE_DATE, SALARY,
       LAST_VALUE(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                                ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                                ) AS ALL_SALARY,
       LAST_VALUE(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                                ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
                                ) AS FR_ST_TO_CURRENT_SAL,
       LAST_VALUE(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                                ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
                                ) AS FR_CURRENT_TO_END_SAL
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID IN (30, 90); 
 
 
SELECT DEPARTMENT_ID, EMP_NAME, HIRE_DATE, SALARY,
       NTH_VALUE(SALARY, 2) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                                  ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                                 ) AS ALL_SALARY,
       NTH_VALUE(SALARY, 2) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                                  ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
                                 ) AS FR_ST_TO_CURRENT_SAL,
       NTH_VALUE(SALARY,2 ) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                                  ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
                                 ) AS FR_CURRENT_TO_END_SAL
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID IN (30, 90) ; 
 
-- 기타 분석 함수 

SELECT DEPARTMENT_ID, EMP_NAME, 
       SALARY
      ,NTILE(4) OVER (PARTITION BY DEPARTMENT_ID 
                         ORDER BY SALARY 
                      ) NTILES
      ,WIDTH_BUCKET(SALARY, 1000, 10000, 4) WIDTHBUACKET
  FROM EMPLOYEES
WHERE DEPARTMENT_ID = 60; 

WITH BASIS AS ( SELECT PERIOD, REGION, SUM(LOAN_JAN_AMT) JAN_AMT
                  FROM KOR_LOAN_STATUS
                 GROUP BY PERIOD, REGION
              ), 
    BASIS2 AS ( SELECT PERIOD, MIN(JAN_AMT) MIN_AMT, MAX(JAN_AMT) MAX_AMT
                  FROM BASIS
                 GROUP BY PERIOD
              )
 SELECT A.PERIOD, 
        B.REGION "최소지역", B.JAN_AMT "최소금액",
        C.REGION "최대지역", C.JAN_AMT "최대금액"
   FROM BASIS2 A, BASIS B, BASIS C
  WHERE A.PERIOD  = B.PERIOD
    AND A.MIN_AMT = B.JAN_AMT 
    AND A.PERIOD  = C.PERIOD
    AND A.MAX_AMT = C.JAN_AMT
  ORDER BY 1, 2;
 
 
WITH BASIS AS (
               SELECT PERIOD, REGION, SUM(LOAN_JAN_AMT) JAN_AMT
                 FROM KOR_LOAN_STATUS
                GROUP BY PERIOD, REGION
              )
SELECT A.PERIOD, 
       MIN(A.REGION) KEEP ( DENSE_RANK FIRST ORDER BY JAN_AMT) "최소지역", 
       MIN(JAN_AMT) "최소금액", 
       MAX(A.REGION) KEEP ( DENSE_RANK LAST ORDER BY JAN_AMT) "최대지역",
       MAX(JAN_AMT) "최대금액"
FROM BASIS A
GROUP BY A.PERIOD
ORDER BY 1, 2;

SELECT DEPARTMENT_ID, EMP_NAME, HIRE_DATE, SALARY,
       ROUND(RATIO_TO_REPORT(SALARY) OVER (PARTITION BY DEPARTMENT_ID 
                                ),2) * 100 AS SALARY_PERCENT
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID IN (30, 90); 
 
 
-- 다중 테이블 INSERT
-- 여러 개의 INSERT문을 한 방에 처리
CREATE TABLE EX7_3 (
       EMP_ID    NUMBER,
       EMP_NAME  VARCHAR2(100));


CREATE TABLE EX7_4 (
       EMP_ID    NUMBER,
       EMP_NAME  VARCHAR2(100));
       
INSERT INTO EX7_3 VALUES (101, '홍길동'); 

INSERT INTO EX7_3 VALUES (102, '김유신');       

INSERT ALL
INTO EX7_3 VALUES (103, '강감찬')
INTO EX7_3 VALUES (104, '연개소문')
SELECT *
FROM DUAL;

INSERT ALL
INTO EX7_3 VALUES (EMP_ID, EMP_NAME)
SELECT 103 EMP_ID, '강감찬' EMP_NAME
FROM DUAL
UNION ALL
SELECT 104 EMP_ID, '연개소문' EMP_NAME
FROM DUAL;


INSERT ALL
INTO EX7_3 VALUES (105, '가가가')
INTO EX7_4 VALUES (105, '나나나')
SELECT *
FROM DUAL;

-- 조건에 따른 다중 INSERT
TRUNCATE TABLE EX7_3;

TRUNCATE TABLE EX7_4;


INSERT ALL
WHEN DEPARTMENT_ID = 30 THEN
  INTO EX7_3 VALUES (EMPLOYEE_ID, EMP_NAME)
WHEN DEPARTMENT_ID = 90 THEN
  INTO EX7_4 VALUES (EMPLOYEE_ID, EMP_NAME)
SELECT DEPARTMENT_ID, 
       EMPLOYEE_ID, EMP_NAME 
FROM  EMPLOYEES;


CREATE TABLE EX7_5 (
       EMP_ID    NUMBER,
       EMP_NAME  VARCHAR2(100));
       
INSERT ALL
WHEN DEPARTMENT_ID = 30 THEN
  INTO EX7_3 VALUES (EMPLOYEE_ID, EMP_NAME)
WHEN DEPARTMENT_ID = 90 THEN
  INTO EX7_4 VALUES (EMPLOYEE_ID, EMP_NAME)
ELSE
  INTO EX7_5 VALUES (EMPLOYEE_ID, EMP_NAME)
SELECT DEPARTMENT_ID, 
       EMPLOYEE_ID, EMP_NAME 
FROM  EMPLOYEES;
       
       
SELECT COUNT(*)
FROM EX7_5;
       
SELECT DEPARTMENT_ID, EMPLOYEE_ID, EMP_NAME,  SALARY
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 30;

INSERT ALL
WHEN EMPLOYEE_ID < 116 THEN
  INTO EX7_3 VALUES (EMPLOYEE_ID, EMP_NAME)
WHEN  SALARY < 5000 THEN
  INTO EX7_4 VALUES (EMPLOYEE_ID, EMP_NAME)
SELECT DEPARTMENT_ID, EMPLOYEE_ID, EMP_NAME,  SALARY
FROM   EMPLOYEES
WHERE  DEPARTMENT_ID = 30;  


SELECT *
FROM EX7_3;

SELECT *
FROM EX7_4;

INSERT FIRST
WHEN EMPLOYEE_ID < 116 THEN
  INTO EX7_3 VALUES (EMPLOYEE_ID, EMP_NAME)
WHEN  SALARY < 5000 THEN
  INTO EX7_4 VALUES (EMPLOYEE_ID, EMP_NAME)
SELECT DEPARTMENT_ID, EMPLOYEE_ID, EMP_NAME,  SALARY
FROM   EMPLOYEES
WHERE  DEPARTMENT_ID = 30;   


