-- 계층형 쿼리
/*
계층형 쿼리HierarchicalQuery 는 2차원 형태의 테이블에 저장된 데이터를 계층형 구조로 결과를 반환하는 쿼리를 말한다. 
계층형 구조란 상하 수직 관계의 구조로 사원-대리-과장-부장과 같은 직급, 판매부-영업부 같은 부서 구조, 대학의 학과, 정부 부처 등이 계층형 구조에 속한다.
또한 엑셀과 같은 프로그램의 메뉴 구조, 답변형 게시판뿐만 아니라 이 책의 목차도 이에 포함된다.
*/

-- 오라클의 계층형쿼리 문법이 지원 안될 때에는 아래 구문으로 계층형 구조결과를 대신하는 쿼리.
SELECT  DEPARTMENT_ID, 
        DEPARTMENT_NAME, 
        0 AS PARENT_ID,
        1 AS LEVELS,
        PARENT_ID || DEPARTMENT_ID AS SORT
FROM    DEPARTMENTS 
WHERE   PARENT_ID IS NULL
UNION ALL
SELECT  T2.DEPARTMENT_ID, 
        LPAD(' ' , 3 * (2-1)) || T2.DEPARTMENT_NAME AS DEPARTMENT_NAME, 
        T2.PARENT_ID,
        2 AS LEVELS,
        T2.PARENT_ID || T2.DEPARTMENT_ID AS SORT
FROM    DEPARTMENTS T1,
        DEPARTMENTS T2
WHERE   T1.PARENT_ID IS NULL
  AND   T2.PARENT_ID = T1.DEPARTMENT_ID
UNION ALL
SELECT  T3.DEPARTMENT_ID, 
        LPAD(' ' , 3 * (3-1)) || T3.DEPARTMENT_NAME AS DEPARTMENT_NAME, 
        T3.PARENT_ID,
        3 AS LEVELS,
        T2.PARENT_ID || T3.PARENT_ID || T3.DEPARTMENT_ID AS SORT
FROM    DEPARTMENTS T1,
        DEPARTMENTS T2,
        DEPARTMENTS T3
WHERE   T1.PARENT_ID IS NULL
  AND   T2.PARENT_ID = T1.DEPARTMENT_ID
  AND   T3.PARENT_ID = T2.DEPARTMENT_ID
UNION ALL
SELECT  T4.DEPARTMENT_ID, 
        LPAD(' ' , 3 * (4-1)) || T4.DEPARTMENT_NAME AS DEPARTMENT_NAME, 
        T4.PARENT_ID,
        4 AS LEVELS,
        T2.PARENT_ID || T3.PARENT_ID || T4.PARENT_ID || T4.DEPARTMENT_ID AS SORT
FROM    DEPARTMENTS T1,
        DEPARTMENTS T2,
        DEPARTMENTS T3,
        DEPARTMENTS T4
WHERE   T1.PARENT_ID IS NULL
  AND   T2.PARENT_ID = T1.DEPARTMENT_ID
  AND   T3.PARENT_ID = T2.DEPARTMENT_ID
  AND   T4.PARENT_ID = T3.DEPARTMENT_ID
ORDER BY SORT;

/*
    SELECT expr1, expr2, ...
      FROM 테이블
     WHERE 조건
     START WITH[최상위 조건] -- 최상위 데이터를 지정
    CONNECT BY [NOCYCLE][PRIOR 계층형 구조 조건];
*/    

/*
department_id : 자식컬럼
parent_id : 부모컬럼
*/

--1)  상위레벨 -> 하위레벨 수준으로 데이타 출력
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL
  FROM DEPARTMENTS
  START WITH PARENT_ID IS NULL  -- 루트가 상위로 본다.
  CONNECT BY PRIOR DEPARTMENT_ID  = PARENT_ID;  -- prior 키워드가 자식컬럼(department_id) 앞에 사용
 
 
  
SELECT      DEPARTMENT_ID, LPAD(' ', 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL
FROM        DEPARTMENTS
-- 최상위 조건
START WITH  PARENT_ID IS NULL
-- 컬럼 둘중 하나에 PRIOR를 입력해 주어야한다.
CONNECT BY  PRIOR DEPARTMENT_ID = PARENT_ID;

--2)  하위레벨 -> 상위레벨 수준으로 데이타 출력  
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL
FROM DEPARTMENTS
START WITH PARENT_ID IS NULL -- 루트가 하위로 본다.
CONNECT BY DEPARTMENT_ID  = PRIOR PARENT_ID;  -- prior 키워드가 부모컬럼(parent_id) 앞에 사용


-- 구매/생산부를 루트로 지정하여, 하위레벨에서 상위레벨로 출력하라.
SELECT      DEPARTMENT_ID, LPAD(' ', 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL
FROM        DEPARTMENTS
START WITH  DEPARTMENT_ID = 30   -- 30   구매/생산부
CONNECT BY  DEPARTMENT_ID = PRIOR PARENT_ID;

-- 구매/생산부를 루트로 지정하여, 상위레벨에서 하위레벨로 출력하라.
SELECT      DEPARTMENT_ID, LPAD(' ', 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL
FROM        DEPARTMENTS
START WITH  DEPARTMENT_ID = 30   -- 30   구매/생산부
CONNECT BY  PRIOR DEPARTMENT_ID =  PARENT_ID;


-- 조인 형태
SELECT      *
FROM        EMPLOYEES;

SELECT      EMPLOYEE_ID, MANAGER_ID
FROM        EMPLOYEES
START WITH  MANAGER_ID IS NULL
CONNECT BY  PRIOR EMPLOYEE_ID = MANAGER_ID;


-- 상급자에서 하급자레벨로 출력하라.  
SELECT A.EMPLOYEE_ID, LPAD(' ' , 3 * (LEVEL-1)) || A.EMP_NAME, 
       LEVEL,
       B.DEPARTMENT_NAME
  FROM EMPLOYEES A,
       DEPARTMENTS B
 WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID
 START WITH A.MANAGER_ID IS NULL
 CONNECT BY PRIOR A.EMPLOYEE_ID = A.MANAGER_ID;


--1) START WITH a.manager_id IS NULL 루트지정한 데이타가 출력안됨.
SELECT A.EMPLOYEE_ID, LPAD(' ' , 3 * (LEVEL-1)) || A.EMP_NAME, 
       LEVEL,
       B.DEPARTMENT_NAME, A.DEPARTMENT_ID
  FROM EMPLOYEES A,
       DEPARTMENTS B
 WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID
   AND A.DEPARTMENT_ID = 30 -- 부서가 30번이 데이타를 전제조건.
 START WITH A.MANAGER_ID IS NULL
 CONNECT BY NOCYCLE PRIOR A.EMPLOYEE_ID = A.MANAGER_ID;

--2)계층형쿼리 이후에 조건식이 사용되면, 루트지정한 데이타가 포함되어 출력된다.
SELECT A.EMPLOYEE_ID, LPAD(' ' , 3 * (LEVEL-1)) || A.EMP_NAME, 
       LEVEL,
       B.DEPARTMENT_NAME, A.DEPARTMENT_ID
  FROM EMPLOYEES A,
       DEPARTMENTS B
 WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID
 START WITH A.MANAGER_ID IS NULL
 CONNECT BY NOCYCLE PRIOR A.EMPLOYEE_ID = A.MANAGER_ID
     AND A.DEPARTMENT_ID = 30; -- 
  
-- 계층형 정렬하기.  

-- ORDER BY 키워드 사용시, 계층형 구조가 유지되지 않고, 단순하게 정렬된다.
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL
  FROM DEPARTMENTS
  START WITH PARENT_ID IS NULL
  CONNECT BY PRIOR DEPARTMENT_ID  = PARENT_ID
  ORDER BY DEPARTMENT_NAME;  

-- ORDER SIBLINGS BY : 계층형 구조가 유지된 상태에서 정렬  
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL
  FROM DEPARTMENTS
  START WITH PARENT_ID IS NULL
  CONNECT BY PRIOR DEPARTMENT_ID  = PARENT_ID
  ORDER SIBLINGS BY DEPARTMENT_NAME;    

/*
② CONNECT_BY_ROOT
CONNECT_BY_ROOT는 계층형 쿼리에서 최상위 로우를 반환하는 연산자다
*/

-- 에러발생. > CONNECT_BY_ROOT 에 부서명을 필수적으로 입력해 주어야한다.-
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL, CONNECT_BY_ROOT
  FROM DEPARTMENTS
  START WITH PARENT_ID IS NULL
  CONNECT BY PRIOR DEPARTMENT_ID  = PARENT_ID
  ORDER SIBLINGS BY DEPARTMENT_NAME;      
  
  
-- 최상위 부서명을 출력함.  
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL, 
       CONNECT_BY_ROOT DEPARTMENT_NAME AS ROOT_NAME
  FROM DEPARTMENTS
  START WITH PARENT_ID IS NULL
  CONNECT BY PRIOR DEPARTMENT_ID  = PARENT_ID;
/*
③ CONNECT_BY_ISLEAF : 하위레벨 존재유무를 확인가능하다.
CONNECT_BY_ISLEAF는 CONNECT BY 조건에 정의된 관계에 따라 
해당 로우가 최하위 자식 로우이면 1을, 그렇지 않으면 0을 반환하는 의사 컬럼이다.
*/
  
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL, CONNECT_BY_ISLEAF
  FROM DEPARTMENTS
  START WITH PARENT_ID IS NULL
  CONNECT BY PRIOR DEPARTMENT_ID  = PARENT_ID;  
 
/*
④ SYS_CONNECT_BY_PATH (colm, char)
SYS_CONNECT_BY_PATH는 계층형 쿼리에서만 사용할 수 있는 함수로, 
루트 노드에서 시작해 자신의 행까지 연결된 경로 정보를 반환한다. 
이 함수의 첫 번째 파라미터로는 컬럼이, 두 번째 파라미터인 char은 컬럼 간 구분자를 의미한다.
*/
  
-- 현재 결과값에 보면 구매/ 생산부 컬럼에 '/'가 있는데, 이것을 사용해선 안된다.
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL, 
       SYS_CONNECT_BY_PATH( DEPARTMENT_NAME, '->')
  FROM DEPARTMENTS
  START WITH PARENT_ID IS NULL
  CONNECT BY PRIOR DEPARTMENT_ID  = PARENT_ID;   
 
 /*
 SYS_CONNECT_BY_PATH( department_name, '/')
 두 번째 매개변수인 구분자로 해당 컬럼 값에 포함된 문자는 사용할 수 없다는 점을 주의해야 한다. 
구매/생산부는 ‘/’문자가 속해 있는데, 구분자로 ‘/’를 사용하면 다음과 같은 오류가 발생한다
 */
 
 -- 에러발생 :  department_name컬럼에 "구매/생산부"   데이터가 존재한다. / 를 포함하고 있다.
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL, 
       SYS_CONNECT_BY_PATH( DEPARTMENT_NAME, '/')
  FROM DEPARTMENTS
  START WITH PARENT_ID IS NULL
  CONNECT BY PRIOR DEPARTMENT_ID  = PARENT_ID;     
 
/*
⑤ CONNECT_BY_ISCYCLE
눈치챘는지는 모르겠지만 오라클의 계층형 쿼리는 루프(반복) 알고리즘을 사용한다. 
계층형 구조나 레벨은 테이블에 있는 데이터에 따라 동적으로 변경되므로, 내부적으로는 루프를 돌며 자식 노드를 찾아간다. 
루프 알고리즘에서 주의할 점은 조건을 잘못 주면 무한루프를 타게 된다는 점인데, 
계층형 쿼리에서도 부모-자식 간의 관계를 정의하는 값이 잘못 입력되면 무한루프를 타고 오류가 발생한다.
*/
 
/*
무한 루프가 발생되는 데이타 변경작업을하여, 테스트하는 시나리오.

예를 들어, 생산팀(170)의 부모 부서는 구매/생산부(30)인데, 
구매/생산부의 parent_id 값을 생산부로 바꾸면 두 부서가 상호 참조가 되어 무한루프가 발생할 것이다. 직접 확인해 보자.
*/

--   구매/생산부의 parent_id 값을 생산부 10번에서 170번으로 변경작업을 한다. 결과는 계층형쿼리에서 무한루프가 발생된다.
UPDATE DEPARTMENTS
   SET PARENT_ID = 170
 WHERE DEPARTMENT_ID = 30;
 
 
-- 부서코드가 30을 루트지정 .
-- 상위레벨에서 하위레벨로 출력
-- 데이터가 잘못 입력되어, 무한루프 에러 발생. CONNECT BY loop in user data
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL, 
       PARENT_ID
  FROM DEPARTMENTS
  START WITH DEPARTMENT_ID = 30 -- 상위레벨
CONNECT BY PRIOR DEPARTMENT_ID  = PARENT_ID; 

/*
이때는 루프가 발생된 원인을 찾아 잘못된 데이터를 수정해야 하는데, 
이를 위해서는 먼저 CONNECT BY 절에 NOCYCLE을 추가하고 
SELECT 절에 CONNECT_BY_ISCYCLE 의사 컬럼을 사용해 찾을 수 있다. 
CONNECT_BY_ISCYCLE은 다음과 같이 현재 로우가 자식을 갖고 있는데 
동시에 그 자식 로우가 부모 로우이면 1을, 그렇지 않으면 0을 반환한다.
*/

-- 시스템 패키지
-- DBMS


SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LEVEL-1)) || DEPARTMENT_NAME AS DEPNAME, LEVEL, 
       CONNECT_BY_ISCYCLE ISLOOP,
       PARENT_ID
  FROM DEPARTMENTS
  START WITH DEPARTMENT_ID = 30
CONNECT BY NOCYCLE PRIOR DEPARTMENT_ID  = PARENT_ID; 

-- 루프 발생시킨 데이타를 확인한다.
-- 원래 상태로 다시 변경한다. 170 -> 10 코드로 변경
UPDATE DEPARTMENTS
   SET PARENT_ID = 10
 WHERE DEPARTMENT_ID = 30;
  
  
-- 계층형 쿼리 응용 
-- 샘플 데이터 생성  

-- 시스템 패키지 : 오라클에서 제공하는 명령어의 집합체.
-- DBMS_RANDOM 패키지.
-- 주요기능 : 랜덤한 숫자나 문자열 만들때 사용.



SET SERVEROUTPUT ON;

SET SERVEROUTPUT OFF;

-- 랜덤값 생성(양수 또는 음수)
SELECT DBMS_RANDOM.RANDOM FROM DUAL;

-- 0~1 범위 사이의 랜덤 값 생성
SELECT SYS.DBMS_RANDOM.VALUE FROM DUAL;

-- 1~1000 사이의 랜덤 값 생성
SELECT DBMS_RANDOM.VALUE(1, 1000) FROM DUAL;

SELECT TRUNC(DBMS_RANDOM.VALUE(1, 1000), -1) FROM DUAL;

-- 12자리 랜덤값 생성
SELECT DBMS_RANDOM.VALUE(100000000000, 999999999999) FROM DUAL;

-- 대문자 20자리 랜덤 문자열 생성
SELECT DBMS_RANDOM.STRING('U', 20) FROM DUAL; -- NVWTRENTWJWZTFHAFIYO

-- 소문자 20자리 랜덤 문자열 생성
SELECT DBMS_RANDOM.STRING('L', 20) FROM DUAL; -- gfjxzhhkqhogifqlnaig

-- 대소문자 혼합 20자리 랜덤 문자열 생성
SELECT DBMS_RANDOM.STRING('A', 20) FROM DUAL; -- FWqmZRnYSooxFRWrSsfn

-- 대문자, 숫자 혼합 20자리 랜덤 문자열 생성
SELECT DBMS_RANDOM.STRING('X', 20) FROM DUAL; -- A77BYPBI7IJJY339H0E8

-- 출력가능한 특수문자포함 20자리 랜덤 문자열 생성
SELECT DBMS_RANDOM.STRING('P', 20) FROM DUAL; -- )ge]&h\yTf8 e>%s+K`a

-- CONNECT BY LEVEL <= 숫자
SELECT DBMS_RANDOM.VALUE(1000, 10000) FROM DUAL;

SELECT CEIL(DBMS_RANDOM.VALUE(1000, 10000)) FROM DUAL;

-- 정수로만 1000~10000 범위에서 임의의 수를 10개 생성하자.
SELECT CEIL(DBMS_RANDOM.VALUE(1000, 10000)) FROM DUAL
CONNECT BY LEVEL <= 10;

-- 테이블 생성(데이타포함) : 데이타 백업 
-- 샘플데이타 작업 : 2014년 1월~12월 데이터
CREATE TABLE EX7_1 AS  
SELECT ROWNUM SEQ, 
       '2014' || LPAD(CEIL(ROWNUM/1000) , 2, '0' ) MONTH,
        ROUND(DBMS_RANDOM.VALUE (100, 1000)) AMT
FROM DUAL
CONNECT BY LEVEL <= 12000;

SELECT * FROM EX7_1;

-- 2014년도 01월~12월 데이타를 가공작업
-- ROWNUM 1~1000
SELECT CEIL(1/1000), CEIL(999/1000), CEIL(1000/1000) FROM DUAL;

-- -- ROWNUM 1001~2000
SELECT CEIL(1001/1000), CEIL(1999/1000), CEIL(2000/1000) FROM DUAL;

-- CREATE TABLE 테이블명 AS SELECT --
-- 참고, TABLE, SELECT 구분 --
-- 참고. INSERT~SELECT 구문.
/*
INSERT INTO 테이블명A
SELECT 컬럼1, 컬럼2 FROM 테이블명B
*/


-- 3월29일까지 진행됨.

SELECT *
  FROM EX7_1;
  
-- 2014년 월별 금액 합계.
SELECT MONTH, SUM(AMT)
FROM EX7_1
GROUP BY MONTH
ORDER BY MONTH;


  
-- 로우를 컬럼으로
-- 부서별 사원이름을 조회하라.

-- 행 <ROW 단위로 출력됨 행= 줄
SELECT DEPARTMENT_ID,EMP_NAME FROM EMPLOYEES
ORDER BY DEPARTMENT_ID
;
-- 전체 사원 목록

CREATE TABLE EX7_2 AS
  SELECT DEPARTMENT_ID,
         LISTAGG(EMP_NAME, ',') WITHIN GROUP (ORDER BY EMP_NAME) AS EMPNAMES
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID IS NOT NULL
  GROUP BY DEPARTMENT_ID;
  
-- 상단의 테이블 생성 및 데이터 확인.
SELECT *
FROM EX7_2;

-- 전체 사원 목록
-- 만일 SELECT 리스트의 DEPARTMENT_ID와 "GROUP BY DEPARTMENT_ID 부분을 없애면
-- 모든 사원을 , 구분자로 하여 전체 사원을 한 행으로 출력

  SELECT 
         LISTAGG(EMP_NAME, ',') WITHIN GROUP (ORDER BY EMP_NAME) AS EMPNAMES
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID IS NOT NULL

                  
  
-- WITH 절

-- 1)
SELECT B2.*
FROM ( SELECT PERIOD, REGION, SUM(LOAN_JAN_AMT) JAN_AMT
         FROM KOR_LOAN_STATUS 
         GROUP BY PERIOD, REGION
      ) B2,      
      ( SELECT B.PERIOD,  MAX(B.JAN_AMT) MAX_JAN_AMT
         FROM ( SELECT PERIOD, REGION, SUM(LOAN_JAN_AMT) JAN_AMT
                  FROM KOR_LOAN_STATUS 
                 GROUP BY PERIOD, REGION
              ) B,
              ( SELECT MAX(PERIOD) MAX_MONTH
                  FROM KOR_LOAN_STATUS
                 GROUP BY SUBSTR(PERIOD, 1, 4)
              ) A
         WHERE B.PERIOD = A.MAX_MONTH
         GROUP BY B.PERIOD
      ) C   
 WHERE B2.PERIOD = C.PERIOD
   AND B2.JAN_AMT = C.MAX_JAN_AMT
 ORDER BY 1;


-- 2)
WITH B2 AS ( SELECT PERIOD, REGION, SUM(LOAN_JAN_AMT) JAN_AMT
               FROM KOR_LOAN_STATUS 
              GROUP BY PERIOD, REGION
           ),
     C AS ( SELECT B.PERIOD,  MAX(B.JAN_AMT) MAX_JAN_AMT
              FROM ( SELECT PERIOD, REGION, SUM(LOAN_JAN_AMT) JAN_AMT
                      FROM KOR_LOAN_STATUS 
                     GROUP BY PERIOD, REGION
                   ) B,
                   ( SELECT MAX(PERIOD) MAX_MONTH
                       FROM KOR_LOAN_STATUS
                      GROUP BY SUBSTR(PERIOD, 1, 4)
                   ) A
             WHERE B.PERIOD = A.MAX_MONTH
             GROUP BY B.PERIOD
           )
SELECT B2.*
  FROM B2, C
 WHERE B2.PERIOD = C.PERIOD
   AND B2.JAN_AMT = C.MAX_JAN_AMT
 ORDER BY 1;           

           
-- 순환 서브쿼리
           
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LEVEL-1)) || DEPARTMENT_NAME, LEVEL
  FROM DEPARTMENTS
  START WITH PARENT_ID IS NULL
  CONNECT BY PRIOR DEPARTMENT_ID  = PARENT_ID;
  
WITH RECUR ( DEPARTMENT_ID, PARENT_ID, DEPARTMENT_NAME, LVL)
        AS ( SELECT DEPARTMENT_ID, PARENT_ID, DEPARTMENT_NAME, 1 AS LVL
               FROM DEPARTMENTS
              WHERE PARENT_ID IS NULL
              UNION ALL
             SELECT A.DEPARTMENT_ID, A.PARENT_ID, A.DEPARTMENT_NAME, B.LVL + 1 
               FROM DEPARTMENTS A, RECUR B
              WHERE A.PARENT_ID = B.DEPARTMENT_ID 
              )             
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LVL-1)) || DEPARTMENT_NAME, LVL
 FROM RECUR;
 
 
WITH RECUR ( DEPARTMENT_ID, PARENT_ID, DEPARTMENT_NAME, LVL)
        AS ( SELECT DEPARTMENT_ID, PARENT_ID, DEPARTMENT_NAME, 1 AS LVL
               FROM DEPARTMENTS
              WHERE PARENT_ID IS NULL
              UNION ALL
             SELECT A.DEPARTMENT_ID, A.PARENT_ID, A.DEPARTMENT_NAME, B.LVL + 1 
               FROM DEPARTMENTS A, RECUR B
              WHERE A.PARENT_ID = B.DEPARTMENT_ID 
              )       
SEARCH DEPTH FIRST BY DEPARTMENT_ID SET ORDER_SEQ                       
SELECT DEPARTMENT_ID, LPAD(' ' , 3 * (LVL-1)) || DEPARTMENT_NAME, LVL, ORDER_SEQ
 FROM RECUR; 


           
-- WITH절 문법 연습
-- 복잡한 SQL에서 동일 블록에 대해 반복적으로 SQL문을 사용하는 경우
-- 그 블록에 이름을 부여하여 재사용하는 용도

WITH EXAMPLE AS 
(
    SELECT 'WITH절' AS STRI FROM DUAL
)
SELECT * FROM EXAMPLE;

-- 2) 다중 WITH 문
WITH EXAMPLE1 AS 
(
    SELECT 'EX1' A FROM DUAL
    UNION ALL
    SELECT '2X2' FROM DUAL
), 
EAMPLE2 AS
(
    SELECT 'EX3' A FROM DUAL
    UNION ALL
    SELECT A FROM EXAMPLE1
)
SELECT * FROM EXAMPLE2;



-- 분석함수
/* 
분석 함수 AnalyticFunction 란 테이블에 있는 로우에 대해 특정 그룹별로 집계 값을 산출할 때 사용된다. 
집계 값을 구할 때 보통은 그룹 쿼리를 사용하는데, 이때 GROUP BY 절에 의해 최종 쿼리 결과는 
그룹별로 로우 수가 줄어든다. 이에 반해, 집계 함수를 사용하면 로우의 손실 없이도 
그룹별 집계 값을 산출해 낼 수 있다. 분석 함수에서 사용하는 로우별 그룹을 
윈도우(window)라고 부르는데, 이는 집계 값 계산을 위한 로우의 범위를 결정하는 역할을 한다.
*/

-- 부서별 급여 합계 
SELECT      DEPARTMENT_ID, SUM(SALARY)
FROM        EMPLOYEES
GROUP BY    DEPARTMENT_ID
ORDER BY    DEPARTMENT_ID;

/*
   분석 함수(매개변수) OVER
       　　　(PARTITION BY expr1, expr2,...
                  ORDER BY expr3, expr4...
                window 절)

*/

-- ① ROW_NUMBER( )
-- ROW_NUMBER는 ROWNUM 의사 컬럼과 비슷한 기능을 하는데, 
-- 파티션으로 분할된 그룹별로 각 로우에 대한 순번을 반환하는 함수다. 
-- 사원 테이블에서 부서별 사원들의 로우 수를 출력해 보자.



SELECT DEPARTMENT_ID, EMP_NAME, 
       ROW_NUMBER() OVER (PARTITION BY DEPARTMENT_ID 
                          ORDER BY EMP_NAME ) DEP_ROWS
  FROM EMPLOYEES;
  
-- RANK 함수는 파티션별 순위를 반환한다. 부서별로 급여 순위를 매겨보자.
  
-- 부서별 급여의 순위를 먹인다.
-- RANK() : 급여가 동일한 데이터에 대하여 공동순위를 매기고,
-- 그 다음 공동 순위 만큼 차이를 두어 그 다음 순위를 매긴다.
SELECT DEPARTMENT_ID, EMP_NAME, 
       SALARY,
       RANK() OVER (PARTITION BY DEPARTMENT_ID 
                    ORDER BY SALARY ) DEP_RANK
  FROM EMPLOYEES;
  
/* 
40	Susan Mavris	    6500	1
50	TJ Olson	        2100	1
50	Steven Markle	    2200	2
50	Hazel Philtanker	2200	2
50	Ki Gee	            2400	4
50	James Landry	    2400	4
*/
  
  
SELECT DEPARTMENT_ID, EMP_NAME, 
       SALARY,
       DENSE_RANK() OVER (PARTITION BY DEPARTMENT_ID 
                    ORDER BY SALARY ) DEP_RANK
  FROM EMPLOYEES;
  
/* 
50	TJ Olson	        2100	1
50	Steven Markle	    2200	2
50	Hazel Philtanker	2200	2
50	Ki Gee	            2400	3
50	James Landry	    2400	3
50	Randall Perkins	    2500	4
50	Martha Sullivan	    2500	4
50	Joshua Patel	    2500	4
50	Peter Vargas	    2500	4
50	James Marlow	    2500	4
*/
  
  
/* 
TOP N 쿼리!
분석 함수는 응용 분야가 매우 많다. 
예를 들어, 특정 조건에 맞는 상위 혹은 하위 n개의 데이터만 추출하는 
TOP n 쿼리도 쉽게 작성할 수 있다. 각 부서별로 급여가 
상위 3위까지인 사원을 추출하는 쿼리를 작성해 보자.
*/ 

-- 1) 상위 3위
SELECT *
FROM ( SELECT DEPARTMENT_ID, EMP_NAME, 
              SALARY, 
              DENSE_RANK() OVER (PARTITION BY DEPARTMENT_ID 
                                 ORDER BY SALARY DESC) DEP_RANK
         FROM EMPLOYEES
     )
WHERE DEP_RANK <= 3;  

-- 2) 하위 3위
SELECT *
FROM ( SELECT DEPARTMENT_ID, EMP_NAME, 
              SALARY, 
              DENSE_RANK() OVER (PARTITION BY DEPARTMENT_ID 
                                 ORDER BY SALARY ASC) DEP_RANK
         FROM EMPLOYEES
     )
WHERE DEP_RANK <= 3;  
    
    
    
SELECT DEPARTMENT_ID, EMP_NAME, 
       SALARY,
       CUME_DIST() OVER (PARTITION BY DEPARTMENT_ID 
                         ORDER BY SALARY ) DEP_DIST
  FROM EMPLOYEES;    
  
  
SELECT DEPARTMENT_ID, EMP_NAME, 
       SALARY
      ,RANK() OVER (PARTITION BY DEPARTMENT_ID 
                         ORDER BY SALARY ) RAKING
      ,CUME_DIST() OVER (PARTITION BY DEPARTMENT_ID 
                         ORDER BY SALARY ) CUME_DIST_VALUE
      ,PERCENT_RANK() OVER (PARTITION BY DEPARTMENT_ID 
                         ORDER BY SALARY ) PERCENTILE
  FROM EMPLOYEES
WHERE DEPARTMENT_ID = 60;  

SELECT DEPARTMENT_ID, EMP_NAME, 
       SALARY
      ,NTILE(4) OVER (PARTITION BY DEPARTMENT_ID 
                         ORDER BY SALARY 
                      ) NTILES
  FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (30, 60) ;

SELECT EMP_NAME, HIRE_DATE, SALARY,
       LAG(SALARY, 1, 0)  OVER (ORDER BY HIRE_DATE) AS PREV_SAL,
       LEAD(SALARY, 1, 0) OVER (ORDER BY HIRE_DATE) AS NEXT_SAL
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID = 30;
 
SELECT EMP_NAME, HIRE_DATE, SALARY,
       LAG(SALARY, 2, 0)  OVER (ORDER BY HIRE_DATE) AS PREV_SAL,
       LEAD(SALARY, 2, 0) OVER (ORDER BY HIRE_DATE) AS NEXT_SAL
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID = 30;
 
 
-- Window절
 
SELECT DEPARTMENT_ID, EMP_NAME, HIRE_DATE, SALARY,
       SUM(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                         ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                         ) AS ALL_SALARY,
       SUM(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                         ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
                         ) AS FIRST_CURRENT_SAL,
       SUM(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                         ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
                         ) AS CURRENT_END_SAL
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID IN (30, 90);
 
SELECT DEPARTMENT_ID, EMP_NAME, HIRE_DATE, SALARY,
       SUM(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                         RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                         ) AS ALL_SALARY,
       SUM(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                         RANGE 365 PRECEDING
                         ) AS RANGE_SAL1,
       SUM(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                         RANGE BETWEEN 365 PRECEDING AND CURRENT ROW
                         ) AS RANGE_SAL2
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID = 30; 
 
 
SELECT DEPARTMENT_ID, EMP_NAME, HIRE_DATE, SALARY,
       FIRST_VALUE(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                                 ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                                ) AS ALL_SALARY,
       FIRST_VALUE(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                                 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
                                ) AS FR_ST_TO_CURRENT_SAL,
       FIRST_VALUE(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                                 ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
                                ) AS FR_CURRENT_TO_END_SAL
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID IN (30, 90); 
 
 
 SELECT DEPARTMENT_ID, EMP_NAME, HIRE_DATE, SALARY,
       LAST_VALUE(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                                ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                                ) AS ALL_SALARY,
       LAST_VALUE(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                                ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
                                ) AS FR_ST_TO_CURRENT_SAL,
       LAST_VALUE(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                                ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
                                ) AS FR_CURRENT_TO_END_SAL
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID IN (30, 90); 
 
 
SELECT DEPARTMENT_ID, EMP_NAME, HIRE_DATE, SALARY,
       NTH_VALUE(SALARY, 2) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                                  ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                                 ) AS ALL_SALARY,
       NTH_VALUE(SALARY, 2) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                                  ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
                                 ) AS FR_ST_TO_CURRENT_SAL,
       NTH_VALUE(SALARY,2 ) OVER (PARTITION BY DEPARTMENT_ID ORDER BY HIRE_DATE
                                  ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
                                 ) AS FR_CURRENT_TO_END_SAL
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID IN (30, 90) ; 
 
-- 기타 분석 함수 

SELECT DEPARTMENT_ID, EMP_NAME, 
       SALARY
      ,NTILE(4) OVER (PARTITION BY DEPARTMENT_ID 
                         ORDER BY SALARY 
                      ) NTILES
      ,WIDTH_BUCKET(SALARY, 1000, 10000, 4) WIDTHBUACKET
  FROM EMPLOYEES
WHERE DEPARTMENT_ID = 60; 

WITH BASIS AS ( SELECT PERIOD, REGION, SUM(LOAN_JAN_AMT) JAN_AMT
                  FROM KOR_LOAN_STATUS
                 GROUP BY PERIOD, REGION
              ), 
    BASIS2 AS ( SELECT PERIOD, MIN(JAN_AMT) MIN_AMT, MAX(JAN_AMT) MAX_AMT
                  FROM BASIS
                 GROUP BY PERIOD
              )
 SELECT A.PERIOD, 
        B.REGION "최소지역", B.JAN_AMT "최소금액",
        C.REGION "최대지역", C.JAN_AMT "최대금액"
   FROM BASIS2 A, BASIS B, BASIS C
  WHERE A.PERIOD  = B.PERIOD
    AND A.MIN_AMT = B.JAN_AMT 
    AND A.PERIOD  = C.PERIOD
    AND A.MAX_AMT = C.JAN_AMT
  ORDER BY 1, 2;
 
 
WITH BASIS AS (
               SELECT PERIOD, REGION, SUM(LOAN_JAN_AMT) JAN_AMT
                 FROM KOR_LOAN_STATUS
                GROUP BY PERIOD, REGION
              )
SELECT A.PERIOD, 
       MIN(A.REGION) KEEP ( DENSE_RANK FIRST ORDER BY JAN_AMT) "최소지역", 
       MIN(JAN_AMT) "최소금액", 
       MAX(A.REGION) KEEP ( DENSE_RANK LAST ORDER BY JAN_AMT) "최대지역",
       MAX(JAN_AMT) "최대금액"
FROM BASIS A
GROUP BY A.PERIOD
ORDER BY 1, 2;

SELECT DEPARTMENT_ID, EMP_NAME, HIRE_DATE, SALARY,
       ROUND(RATIO_TO_REPORT(SALARY) OVER (PARTITION BY DEPARTMENT_ID 
                                ),2) * 100 AS SALARY_PERCENT
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID IN (30, 90); 
 
 
-- 다중 테이블 INSERT
-- 여러 개의 INSERT문을 한 방에 처리

--   다중 테이블 INSERT 구문은 단 하나의 INSERT 문장으로 여러 개의 INSERT 문을 
--   수행하는 효과를 낼 수 있을 뿐만 아니라 특정 조건에 맞는 데이터만 특정 테이블에 
--   입력되게 할 수 있는 문장이다. 
--   먼저 다중 테이블 INSERT 문의 구문을 살펴 보자.


-- INSERT ALL| FIRST
--    WHEN 조건1 THEN
--    　INTO [스키마.]테이블명(컬럼1, 컬럼2, ...) VALUES(값1, 값2, ...)
--    WHEN 조건2 THEN
--    　INTO [스키마.]테이블명(컬럼1, 컬럼2, ...) VALUES(값1, 값2, ...)
--        ...
--     ELSE
--    　 INTO [스키마.]테이블명(컬럼1, 컬럼2, ...) VALUES(값1, 값2, ...)
--    SELECT 문;

CREATE TABLE EX7_3 (
       EMP_ID    NUMBER,
       EMP_NAME  VARCHAR2(100));


CREATE TABLE EX7_4 (
       EMP_ID    NUMBER,
       EMP_NAME  VARCHAR2(100));
       
INSERT INTO EX7_3 VALUES (101, '홍길동'); 

INSERT INTO EX7_3 VALUES (102, '김유신');       

INSERT ALL
INTO EX7_3 VALUES (103, '강감찬')
INTO EX7_3 VALUES (104, '연개소문')
SELECT *
FROM DUAL;

INSERT ALL
INTO EX7_3 VALUES (EMP_ID, EMP_NAME)
SELECT 103 EMP_ID, '강감찬' EMP_NAME
FROM DUAL
UNION ALL
SELECT 104 EMP_ID, '연개소문' EMP_NAME
FROM DUAL;

SELECT * FROM EX7_3;


INSERT ALL
INTO EX7_3 VALUES (105, '가가가')
INTO EX7_4 VALUES (105, '나나나')
SELECT *
FROM DUAL;

-- 조건에 따른 다중 INSERT

-- COMMIT, ROLLBACK 기능이 적용되지 않음.
-- 실제 데이터를 제거하는 것이 아닌, 데이터의 주소를 잘라버린다.

TRUNCATE TABLE EX7_3;

TRUNCATE TABLE EX7_4;


-- 사용 빈도




INSERT ALL
WHEN    DEPARTMENT_ID = 30 THEN
    INTO EX7_3 VALUES (EMPLOYEE_ID, EMP_NAME)
WHEN    DEPARTMENT_ID = 90 THEN
    INTO EX7_4 VALUES (EMPLOYEE_ID, EMP_NAME)
SELECT  DEPARTMENT_ID, 
        EMPLOYEE_ID, EMP_NAME 
FROM    EMPLOYEES;

INSERT ALL
WHEN    DEPARTMENT_ID=30 THEN
    INTO    EX7_3 VALUES(EMPLOYEE_ID, EMP_NAME)
WHEN    DEPARTMENT_ID = 90 THEN
    INTO    EX7_4   VALUES(EMPLOYEE_ID, EMP_NAME)
SELECT  DEPARTMENT_ID, 
        EMPLOYEE_ID, EMP_NAME     
FROM    EMPLOYEES;





CREATE TABLE EX7_5 (
       EMP_ID    NUMBER,
       EMP_NAME  VARCHAR2(100));
       
INSERT ALL
WHEN DEPARTMENT_ID = 30 THEN
  INTO EX7_3 VALUES (EMPLOYEE_ID, EMP_NAME)
WHEN DEPARTMENT_ID = 90 THEN
  INTO EX7_4 VALUES (EMPLOYEE_ID, EMP_NAME)
ELSE
  INTO EX7_5 VALUES (EMPLOYEE_ID, EMP_NAME)
SELECT DEPARTMENT_ID, 
       EMPLOYEE_ID, EMP_NAME 
FROM  EMPLOYEES;
       
SELECT * FROM EX7_3;

SELECT * FROM EX7_4;
       
SELECT * FROM EX7_5;
       
SELECT COUNT(*)
FROM EX7_5;
       
SELECT DEPARTMENT_ID, EMPLOYEE_ID, EMP_NAME,  SALARY
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 30;


-- EX7_3, 7_4 삭제후 재작업
TRUNCATE TABLE EX7_3;
TRUNCATE TABLE EX7_4;

SELECT * FROM EX7_3;
SELECT * FROM EX7_4;


--1) WHEN 조건식이 TRUE이면 데이터를 삽입하라.
INSERT ALL
WHEN EMPLOYEE_ID < 116 THEN
  INTO EX7_3 VALUES (EMPLOYEE_ID, EMP_NAME)
WHEN  SALARY < 5000 THEN
  INTO EX7_4 VALUES (EMPLOYEE_ID, EMP_NAME)
SELECT DEPARTMENT_ID, EMPLOYEE_ID, EMP_NAME,  SALARY
FROM   EMPLOYEES
WHERE  DEPARTMENT_ID = 30;  


SELECT *
FROM EX7_3;

SELECT *
FROM EX7_4;


-- 2) 첫번째 WHEN절에 TRUE가 되어 , 삽입된 데이터 행이 존재하면,
--    이미 이전 단계에서 입력이 되었으므로, 두번째 WHEN절이 TRUE 가 되어 
--    그 로우(데이터행)는 추가로 입력되지 안흔다.
INSERT FIRST
-- EMPLOYEE_ID 가 115번 데이터는 삽입된다 
WHEN EMPLOYEE_ID < 116 THEN
  INTO EX7_3 VALUES (EMPLOYEE_ID, EMP_NAME)
  -- EMPLOYEE_ID 가 115번 데이터는 SALARY<5000보다 작은 경우일지라도, 삽입 되지 않는다.
WHEN  SALARY < 5000 THEN
  INTO EX7_4 VALUES (EMPLOYEE_ID, EMP_NAME)
SELECT DEPARTMENT_ID, EMPLOYEE_ID, EMP_NAME,  SALARY
FROM   EMPLOYEES
WHERE  DEPARTMENT_ID = 30;   


