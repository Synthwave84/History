import Link from "next/link"
import "./globals.css";
// html의 head태그안의 내용을 생성하는 부분이다.

/*

<title>WEB tutorial</title>
<meta name="description" content="Generated by Synthwave84">

*/
export const metadata = {
  title: 'WEB tutorial',
  description: 'Generated by Synthwave84',
}



export default async function RootLayout({ children }) {
// 서버측의 캐시가 작동되어 새로 추가, 변경된 내용이 반영되지 않으므로
// 매번 요청시 캐시가 작동되지 않고, 새로운 작업진행이 되도록 한다.
  const resp = await fetch('http://localhost:9999/topics', {cache:'no-cache'}); 

  const topics = await resp.json();

  // 깨발자의 콘솔에서는 값이 나타나지 않고, 터미널에 표기된다.
  // 클라이언트(브라우저) 에서 확인하는 것이 아니라, 서버(터미널) 에서 확인 해야한다.
  // 왜냐하면 기본은 서버컴포넌트이기 때문이다. 즉 동작은 서버에서 실행되고, html코드로 표현만 될 뿐이다.
  // 참고로, 클라이언트 컴포넌트도 작업이 가능하다. 
  // 서버쪽에서 브라우저에게 보여주는 내용이 생성된다는 의미로 server side rendering이라고 한다. 
 // console.log(topics);

  return (
    <html>
      <body>
      
        <h1>
          {/*a태그를 Link태그로 변환하게되면, 다음과 같은 기능이 제공된다.
          링크 클릭시 새로고침이 발생하지 않음. 필요한 컨텐츠만 로딩된다. 
          이미 방문한 페이지는 캐시가 지원되어, 다시 다운로드 되지 않는다.  
          미리 페이지를 로드 했다가, 실제 요청이 있을 때 클라이언트축에서 응답한다.
        결과적으로, next.js에서는 외부주소를 요청시 작업은 <a>태그를 사용하고,
        운영서버 요청은 <Link>태그를 사용한다.  
        그래서, SPA를 매우 쉽게 구현 할 수 있다. 
          */}
          <Link href='/'>WEB</Link></h1>
          
          <ol>
            {
              topics.map(topic => {
                return <li key={topic.id}><Link href={`/read/${topic.id}`}>{topic.title}</Link></li>
              })
            }
          </ol>
        
        {children}{/* page.js가 들어간다. */} 
        <ul>
            <li><Link href='/create'>create</Link></li>
            <li><Link href='/update/id'>update</Link></li>
            <li><button>delete</button></li>
        </ul>
        </body>
    </html>
  )
}
